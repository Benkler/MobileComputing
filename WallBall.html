<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Mobile Computing WallBall</title>
    <style>
        {        
            padding: 0;
            margin: 0;
        }
        body {
            background-color: #37038A;
        }
        canvas {
            background: #37038A;
            display: block;
            margin: 0 auto;
        }
        
        div {
            background-color: #F5F1CE;
        }
        
    </style>
    <!-- Viewport setzt Inhalt auf passende breite je nach Gerät; initial scale das Zoom level beim laden; user scalable bedeuted zoomen-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
</head>

<body onorientationchange="setScreen();">
	<!--IMPORTANT: I only focus on getting chrome-support  -->

    <script>
		
		//Startzeit des Timers
        var startTime;
		
		//Main Pitch 
        var pitch;
		
		//Kontext des Spielfeldes
        var ctx;
		//Bildschirmverhältnis
        var ratio;

        
        var accely = 0.0;
        
        //Spiel läuft?
        var running = false;
		
        
        //Show InfoScreen, start Game on Click
		function showInfoScreen(txt){
            var showDiv = document.createElement('div');
            showDiv.id = "showDiv";
            showDiv.style.heihght = 400;
            showDiv.style.textDecoration = "underline";
            showDiv.style.textAlign = "center";
            showDiv.style.paddingTop = "100px";
            showDiv.style.background = "#F6D8CE";
            document.body.appendChild(showDiv);
			var btnText = document.createTextNode(txt);
			showDiv.appendChild(btnText);
			showDiv.addEventListener("click", function() {	
				showDiv.parentNode.removeChild(showDiv);
                
           
				initPitch();
				init();
                
                //Set page refresh for game ==> Execute draw() function
				refreshID = setInterval(draw, refresh);
                
                //Only works for Chrome
                pitch.webkitRequestFullScreen();                
			}, false);
		}
		
        //Setzt die Attribute für das Spielfeld
		function initPitch(){
			canvas = document.createElement('canvas');		
			canvas.id = "myCanvas";
			canvas.width = "800";
			canvas.height = "400";
			canvas.style = "border:3px solid #61210B;";		
			document.body.appendChild(canvas);
			ctx = canvas.getContext("2d");
		}
		
        //Setzt die Größenverhältnisse innerhalb des Spielfeldes passend zum Bildschirmverhältnis
		function setScreen(){
            var width = canvas.width;
            var height = canvas.height;        
            //canvas.webkitRequestFullScreen();                
			ratio = width / height;
            //Höhe und Breite passend zum Seitenverhältnis
            var heightval;
            var widthval;
			//innerWidth/innerHeight < 4:3
			if ((innerWidth / innerHeight) < ratio) {
				//Scrollbalken verhindern => -16
				widthval = window.innerWidth - 16;
				heightval = (widthval / ratio) - 16;
                canvas.style.height = heightval + "px";
                canvas.style.width = widthval + "px";
            //innerWidth/innerHeight >= 4:3
			} else {
				heightval = window.innerHeight - 16;
				widthval = (heightval * ratio) - 16;
                canvas.style.height = heightval + "px";
                canvas.style.width = widthval + "px";
			}		
		}
		
		function init(){
			setScreen();
            //Timer starten für Spielzeit
			startTime = new Date();
            
			//Trägheit des Balles
			ballInertiax = BALLINERTIA;
			ballInertiay = BALLINERTIA;
			//Trägheitsbehaftete Beschleunigung
			//phoneTilt = accel * ballInertia;
			phoneTiltx = 0;
			phoneTilty = 0;
			//Aktuell ausgelesene Beschleunigung aus dem Beschleunigungssensor
			accelx = 0.0;
			accely = 0.0;
			//Beschleunigung im letzten Intervall
			// aktuelle Beschleunigung * letzte < 0 bedeutet Richtungsänderung
			lastAccx = 0;
			lastAccy = 0;
			//Position des Balls
			x = XINIT;
			y = YINIT;
			//Hindernis mit dem der Ball im letzten Intervall kollidiert ist
			lastBrickx = -1;
			lastBricky = -1;			
			
			running = true;
			pocketed = false;
			refresh = 10;
		}
		
        //Prüft ob ein Wert innerhalb des Intervalls [smallv,bigv] liegt
        //Gibt value, smallv oder bigv zurück
        function valueBetween(value, smallv, bigv) {
            return value < smallv ? smallv : value > bigv ? bigv : value;
        }
        
        
       
        
       
        //Zeichnet die aktuelle Position des Balles
        function drawBall() {
            //Neues Tempo = (Altes + Neigung) * Reibung
            ballSpeedx = (ballSpeedx + phoneTiltx) * BALLFRICTION;
            ballSpeedy = (ballSpeedy + phoneTilty) * BALLFRICTION;
            //Tunneln verhindern
            if (ballSpeedx > MAXACCEL)
                ballSpeedx = MAXACCEL;
            if (ballSpeedx < -MAXACCEL)
                ballSpeedx = -MAXACCEL;
            if (ballSpeedy > MAXACCEL)
                ballSpeedy = MAXACCEL;
            if (ballSpeedy < -MAXACCEL)
                ballSpeedy = -MAXACCEL;
            //Wenn Kugel sehr langsam ist soll sie still liegen
            if (Math.abs(ballSpeedx) > 0.01)
                x = x + ballSpeedx;
            if (Math.abs(ballSpeedy) > 0.01)
                y = y + ballSpeedy;
            //Ball zeichnen    
            ctx.beginPath();
            ctx.arc(x, y, BALLRADIUS, 0, Math.PI * 2);
            ctx.fillStyle = "#A4A4A4";
            ctx.fill();
            ctx.closePath();
        }
        //Hindernisse zeichnen
        function drawBricks() {
            for (var c = 0; c < brickCount; c++) {
                ctx.beginPath();
                ctx.rect(bricks[c].x, bricks[c].y, bricks[c].width, bricks[c].height);
                ctx.fillStyle = "#61210B";
                ctx.fill();
                ctx.closePath();
            }
        }

		
        //Aktuellen Spielzustand zeichnen
        function draw() {
            if (running) {
                setScreen();
				//Ball bewegt sich von der Wand weg, Ballträgheit zurücksetzen
                if (lastAccx * accelx < 0){
					ballInertiax = BALLINERTIA;
					lastBricky = -1;
				}
                if (lastAccy * accely < 0) {
					ballInertiay = BALLINERTIA;
					lastBrickx = -1;
				}
                
                lastAccx = accelx;
                lastAccy = accely;
                
                phoneTiltx = accelx * ballInertiax;
                phoneTilty = -accely * ballInertiay;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBricks();
                drawHoles();
                collisionDetection();
                drawStartStop();
                drawStopWatch(setStopWatch());
                drawBall();
                handleHoles();
            } else {
				if (!pocketed){
					//Bildschirmwiederholung stoppen
					clearInterval(refreshID);
					//Canvas löschen
					canvas.parentNode.removeChild(canvas);					
					showInfoScreen("Gewonnen! Zeit: " + setStopWatch() + " zum Wiederholen klicken.");
				} else {
					startTime = new Date();
					init();
				}
			}
        }
        
        //This is executed when site is rendered
        if (window.DeviceOrientationEvent) {
            window.addEventListener("devicemotion", function (event) {
                switch (window.orientation) {
                
                    case 0:<!-- Normal Portrait: We want only landscape specific calculation: Use case 90°-->
                       accely = event.accelerationIncludingGravity.y;;
                        break;
                    case 90:<!-- Normal  Landscape-->
                        accely = event.accelerationIncludingGravity.y;
                        break;
                    case -90:<!--Inverted Landscape -->
                        accely = event.accelerationIncludingGravity.y * (-1);
                        break;
                  
                    case 180:<!-- Inverse Portrait: We want only landscape specific calculation: Use case -90°-->
                        accely = event.accelerationIncludingGravity.y * (-1);
                        break;
                }
            }, true);
        } else {
            alert("Sorry no device Orientation supported");
        }
		showInfoScreen('Spiel im Vollbildmodus starten!');
	
    </script>
</body>
</html>