<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Mobile Computing WallBall</title>
    <style>
        {        
            padding: 0;
            margin: 0;
        }
        body {
            background-color: #37038A;
        }
        canvas {
            background: #37038A;
            display: block;
            margin: 0 auto;
        }
        
        div {
            background-color: #F5F1CE;
        }
        
    </style>
    <!-- Viewport setzt Inhalt auf passende breite je nach Gerät; initial scale das Zoom level beim laden; user scalable bedeuted zoomen-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
</head>

<body onorientationchange="setScreen();">
	<!--IMPORTANT: I only focus on getting chrome-support  -->

    <script>
		
		//Startzeit des Timers
        var startTime;
		
		//Main Pitch 
        var canvas;
		
		//Game Context
        var ctx;
        
		//Screen Proportions
        var ratio;

        //Moving Rectangle
        var maxX = 800; //To be set 
        var minX = 1; // 1 px away from left wall
        const rectHeight = 8;
        const rectWidth = 26;
        var rectX = 0;
        var rectY = 0;
        
        
        var accelx = 0.0;
        
        //Spiel läuft?
        var running = false;
		
        
        //Show InfoScreen, start Game on Click
		function showInfoScreen(txt){
            var showDiv = document.createElement('div');
            showDiv.id = "showDiv";
            showDiv.style.heihght = 400;
            showDiv.style.textDecoration = "underline";
            showDiv.style.textAlign = "center";
            showDiv.style.paddingTop = "100px";
            showDiv.style.background = "#F6D8CE";
            document.body.appendChild(showDiv);
			var btnText = document.createTextNode(txt);
			showDiv.appendChild(btnText);
			showDiv.addEventListener("click", function() {	
				showDiv.parentNode.removeChild(showDiv);
                
           
				initPitch();
				init();
                
                //Set page refresh for game ==> Execute draw() function
				refreshID = setInterval(draw, refresh);
                
                //Only works for Chrome
               // canvas.webkitRequestFullScreen();                
			}, false);
		}
		
        //Setzt die Attribute für das Spielfeld
		function initPitch(){
			canvas = document.createElement('canvas');		
			canvas.id = "myCanvas";
			canvas.width = "800";
			canvas.height = "400";
			canvas.style = "border:3px solid #61210B;";		
			document.body.appendChild(canvas);
			ctx = canvas.getContext("2d");
		}
		
        //Adapt screen according to screen proportion
        // Fit Canvas on screen, taking either max high or max width
		function setScreen(){
            //get proportions of canvas
            var width = canvas.width;
            var height = canvas.height;        
                            
			ratio = width / height; // 800/400=2
            var heightval;
            var widthval;
			
            //i.e. Portrait mode, 
			if ((window.innerWidth / window.innerHeight) < ratio) { 
				//Prevent Scrollbar => -16
				widthval = window.innerWidth - 16;
				heightval = (widthval / ratio) - 16;
                canvas.style.height = heightval + "px";
                canvas.style.width = widthval + "px";
                
            //i.e Landscape Mode
			} else {
				heightval = window.innerHeight - 16;
				widthval = (heightval * ratio) - 16;
                canvas.style.height = heightval + "px";
                canvas.style.width = widthval + "px";
			}		
		}
		
		function init(){
			setScreen();
            //Timer starten für Spielzeit
			startTime = new Date();
            
            //start coordinate rectangle
			rectY = canvas.height - (rectHeight + 2); //Y coordinate at bottom of field plus 2 Pixel distance
            rectX = (canvas.width / 2) - (rectWidth / 2); //Start x coordinate in middle
		    
            //Max/Min value for the rectangle
            maxX = canvas.width - (rectWidth + 1); 
            minX = 1; 
        
			accelx = 0.0;
		
			lastAccx = 0;
		
					
			
			running = true;
			loose = false;
			refresh = 10;
		}
		
        //Prüft ob ein Wert innerhalb des Intervalls [smallv,bigv] liegt
        //Gibt value, smallv oder bigv zurück
        function valueBetween(value, smallv, bigv) {
            return value < smallv ? smallv : value > bigv ? bigv : value;
        }
        
        
       
        
       
        //Zeichnet die aktuelle Position des Balles
        function drawBall() {
            //Neues Tempo = (Altes + Neigung) * Reibung
            ballSpeedx = (ballSpeedx + phoneTiltx) * BALLFRICTION;
            ballSpeedy = (ballSpeedy + phoneTilty) * BALLFRICTION;
            //Tunneln verhindern
            if (ballSpeedx > MAXACCEL)
                ballSpeedx = MAXACCEL;
            if (ballSpeedx < -MAXACCEL)
                ballSpeedx = -MAXACCEL;
            if (ballSpeedy > MAXACCEL)
                ballSpeedy = MAXACCEL;
            if (ballSpeedy < -MAXACCEL)
                ballSpeedy = -MAXACCEL;
            //Wenn Kugel sehr langsam ist soll sie still liegen
            if (Math.abs(ballSpeedx) > 0.01)
                x = x + ballSpeedx;
            if (Math.abs(ballSpeedy) > 0.01)
                y = y + ballSpeedy;
            //Ball zeichnen    
            ctx.beginPath();
            ctx.arc(x, y, BALLRADIUS, 0, Math.PI * 2);
            ctx.fillStyle = "#A4A4A4";
            ctx.fill();
            ctx.closePath();
        }
        
        
        function drawRectangle(){
        
        var newRectX = rectX + accelx *2;
        
        rectX = valueBetween(newRectX, minX, maxX);
        
        ctx.beginPath()
        ctx.rect(rectX, rectY,rectWidth, rectHeight);
        ctx.fillStyle = "#61210B";
        ctx.fill();
        ctx.closePath();
        
       
        
        }

		
        //Aktuellen Spielzustand zeichnen
        function draw() {
            if (running) {
                setScreen();
                ctx.clearRect(0, 0, canvas.width, canvas.height); //clear Rectangle, delete all Stuff
                
                
                
                
                
                drawRectangle();
            } else {
				if (!loose){
					//Bildschirmwiederholung stoppen
					clearInterval(refreshID);
					//Canvas löschen
					canvas.parentNode.removeChild(canvas);					
					showInfoScreen("Gewonnen! Zeit: " + setStopWatch() + " zum Wiederholen klicken.");
				} else {
					startTime = new Date();
					init();
				}
			}
        }
        
        //This is executed when site is rendered
        if (window.DeviceOrientationEvent) {
            window.addEventListener("devicemotion", function (event) {
           
                switch (window.orientation) {
                
                    case 0:<!-- Normal Portrait: We want only landscape specific calculation: Use case 90°-->
                       accelx = event.accelerationIncludingGravity.y;;
                        break;
                    case 90:<!-- Normal  Landscape-->
                        accelx = event.accelerationIncludingGravity.y;
                        break;
                    case -90:<!--Inverted Landscape -->
                        accelx = event.accelerationIncludingGravity.y * (-1);
                        break;
                  
                    case 180:<!-- Inverse Portrait: We want only landscape specific calculation: Use case -90°-->
                        accelx = event.accelerationIncludingGravity.y * (-1);
                        break;
                }
            }, true);
        } else {
            alert("Sorry no device Orientation supported");
        }
		showInfoScreen('Spiel im Vollbildmodus starten!');
	
    </script>
</body>
</html>